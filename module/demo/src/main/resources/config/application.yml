server:
  port: 18010

spring:
  application:
    name: demo
  datasource:
    ds1:
      jdbc-url: jdbc:mysql://localhost:3306/test?autoReconnect=true&useSSL=false&allowMultiQueries=true&zeroDateTimeBehavior=convertToNull&failOverReadOnly=false&serverTimezone=GMT%2B8
      username: root
      password: root
    ds2:
      jdbc-url: jdbc:mysql://localhost:3306/test1?autoReconnect=true&useSSL=false&allowMultiQueries=true&zeroDateTimeBehavior=convertToNull&failOverReadOnly=false&serverTimezone=GMT%2B8
      username: root
      password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      pool-name: HikariCP
      minimum-idle: 5
      idle-timeout: 180000
      maximum-pool-size: 10
      auto-commit: true
      max-lifetime: 1800000
      connection-timeout: 30000
      connection-test-query: SELECT 1
  rabbitmq:
    host: localhost
    virtual-host: /
    username: guest
    password: guest
    port: 5672
  kafka:
    producer:
      bootstrap-servers: 127.0.0.1:9092
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      retries: 3
      buffer-memory: 40960
      batch-size: 4096
    consumer:
      group-id: kafka_group
      auto-offset-reset: latest
      enable-auto-commit: false
      auto-commit-interval: 1000
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
    listener:
      # MANUAL	poll()拉取一批消息，处理完业务后，手动调用Acknowledgment.acknowledge()先将offset存放到map本地缓存，在下一次poll之前从缓存拿出来批量提交
      # MANUAL_IMMEDIATE	每处理完业务手动调用Acknowledgment.acknowledge()后立即提交
      # RECORD	当每一条记录被消费者监听器（ListenerConsumer）处理之后提交
      # BATCH	当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交
      # TIME	当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交
      # COUNT	当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交
      # COUNT_TIME	TIME或COUNT满足其中一个时提交
      ack-mode: manual_immediate
  redis:
    cluster:
      nodes: "redis://127.0.0.1:6379,redis://127.0.0.1:6380,redis://127.0.0.1:6381,redis://127.0.0.1:6382,redis://127.0.0.1:6383,redis://127.0.0.1:6384"
    timeout: 60000
  curator:
    retry-count: 5  #重试次数
    elapsed-time-ms: 5000   #重试间隔时间
    connect-string: 127.0.0.1:2181   #zookeeper地址
    session-timeout-ms: 60000  #session超时时间
    connection-timeout-ms: 15000  #连接超时时间

rocketmq:
  name-server: 127.0.0.1:9876
  producer:
    group: transcation-group

mybatis:
  type-aliases-package: com.hezhenrui.domain.*
  mapper-locations: classpath*:mapper/*.xml
  configuration:
    auto-mapping-behavior: partial
    map-underscore-to-camel-case: true

logging:
  config: classpath:logback/logback-spring.xml
  exception-conversion-word: '%wEx'
  level:
    root: info
    com.hezhenrui.demo: debug
  file:
    name: ${spring.application.name}.log
    path: ./logs/${spring.application.name}/

hezhenrui:
  thread-core:
    keep-alive-time: 20000
    thread-name-prefix: hezhenrui-demo-exec-
    capacity: 50
  mapper:
    base-packages:
      test: com.hezhenrui.demo.mapper.test
      test1: com.hezhenrui.demo.mapper.test1